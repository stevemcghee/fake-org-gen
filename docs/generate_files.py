# This file was generated by the Gemini CLI.
# For more information, see: https://github.com/google-gemini/gemini-cli
#
#      ,ad8888ba,
#     d8"'    `"8b
#    d8'        `8b
#    88          88
#    88          88
#    Y8,        ,8P
#     Y8a.    .a8P
#      `"Y8888Y"'
#

import argparse
import os
import random
import json
import io
import re
from faker import Faker
from docx import Document
import xlsxwriter
from pptx import Presentation
from PIL import Image
from fpdf import FPDF
from google import genai
from google.genai import types

def sanitize_filename(title):
    """Converts a title into a safe filename."""
    sanitized = re.sub(r'[\\/*?:"<>|]', "", title)
    sanitized = sanitized.replace(" ", "_")
    return sanitized[:100]

def generate_unique_gemini_content(theme, role, file_type, doc_types, sheet_types, ppt_types, pdf_types, api_key=None):
    """Generates unique, themed content for a specific file type by calling the Gemini API."""
    if not api_key:
        api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise ValueError("GEMINI_API_KEY not found in config or environment variables.")

    client = genai.Client(api_key=api_key)

    if file_type == "document":
        doc_type = random.choice(doc_types)
        content_prompt = f'- "doc_title": "A title for a {doc_type} created by a {role}".\n- "doc_body": "A 6-paragraph body for the document, relevant to the theme, the document type of {doc_type}, and the role of {role}".'
    elif file_type == "spreadsheet":
        sheet_type = random.choice(sheet_types)
        content_prompt = f'- "sheet_title": "A title for a {sheet_type} created by a {role}".\n- "sheet_headers": "A list of 4-6 relevant column headers for the {sheet_type} created by a {role}".\n- "sheet_data": "A list of 15 lists, where each inner list is a row of realistic data for the {sheet_type} created by a {role}".'
    elif file_type == "presentation":
        ppt_type = random.choice(ppt_types)
        content_prompt = f'- "ppt_title": "A title for a {ppt_type} created by a {role}".\n- "ppt_slide_details": "A JSON object with 4 slide titles as keys and a JSON list of 3-5 short, concise bullet points for each slide\u0027s body, relevant to a {ppt_type} created by a {role}".'
    elif file_type == "image":
        art_styles = ["photorealistic", "oil painting", "watercolor", "art deco", "cyberpunk", "fantasy art", "impressionistic", "surreal", "minimalist", "art nouveau"]
        settings = ["a grand hall", "a sun-dappled forest", "a modern office", "a futuristic cityscape", "a subterranean cavern", "a mountaintop observatory", "a bustling marketplace"]
        moods = ["serious", "whimsical", "optimistic", "mysterious", "serene", "dramatic", "inspirational"]
        compositions = ["wide shot", "close-up", "dynamic angle", "symmetrical", "asymmetrical", "leading lines", "rule of thirds"]

        style = random.choice(art_styles)
        setting = random.choice(settings)
        mood = random.choice(moods)
        composition = random.choice(compositions)

        content_prompt = f'- "image_prompt": "A concise, highly creative, and descriptive prompt for an AI image model. The prompt must be unique and not a repeat of previous requests. Incorporate the following elements: theme: \'{theme}\', creator\u0027s role: \'{role}\', artistic style: \'{style}\', setting: \'{setting}\', mood: \'{mood}\', composition: \'{composition}\'. Be imaginative and avoid clichés.".'
    elif file_type == "pdf":
        pdf_type = random.choice(pdf_types)
        content_prompt = f'- "pdf_title": "A title for a {pdf_type} created by a {role}".\n- "pdf_body": "A 6-paragraph body for the document, relevant to the theme, the document type of {pdf_type}, and the role of {role}".'
    else:
        return None

    prompt = f"""
    You are a creative assistant that generates realistic, unique business documents for a fictional company.
    The business theme is: "{theme}"
    The requested file type is: "{file_type}"
    The role of the creator is: "{role}"

    Generate content for the following items in valid JSON format:
    {content_prompt}
    """
    try:
        response = client.models.generate_content(
            model="gemini-2.5-flash",
            contents=prompt
        )
        clean_response = response.text.strip().replace("```json", "").replace("```", "")
        return json.loads(clean_response)
    except (json.JSONDecodeError, Exception) as e:
        print(f"Error parsing Gemini text response: {e}")
        return None



def generate_image_from_api(prompt, file_path, api_key=None):
    """Generates an image using the Gemini API."""
    try:
        if not api_key:
            api_key = os.getenv("GEMINI_API_KEY")
        client = genai.Client(api_key=api_key)
        print(f"Submitting unique image prompt to Gemini: '{prompt}'")
        response = client.models.generate_content(
            model="gemini-2.0-flash-preview-image-generation",
            contents=prompt,
            config=types.GenerateContentConfig(response_modalities=['TEXT', 'IMAGE'])
        )
        for part in response.candidates[0].content.parts:
            if part.inline_data:
                image = Image.open(io.BytesIO(part.inline_data.data))
                image.save(file_path)
                print(f"Successfully generated and saved AI image: {file_path}")
                return
    except Exception as e:
        print(f"Could not generate or save image due to an API error: {e}")
        img = Image.new('RGB', (800, 600), color=(50, 10, 10))
        from PIL import ImageDraw
        d = ImageDraw.Draw(img)
        d.text((10, 10), f"Image generation failed.\nError: {e}", fill=(255, 255, 255))
        img.save(file_path)


def generate_document(user, org_name, file_path, fake, theme_content):
    doc = Document()
    doc.add_heading(f'{org_name} - {theme_content["doc_title"]}', 0)
    p = doc.add_paragraph(f'This document is the property of {org_name}. ')
    p.add_run('Prepared by: ').bold = True
    p.add_run(user)
    doc.add_paragraph()
    doc_body = theme_content.get("doc_body", "")
    if isinstance(doc_body, list):
        for paragraph in doc_body:
            doc.add_paragraph(paragraph)
    elif isinstance(doc_body, str):
        for paragraph in doc_body.split('\n'):
            doc.add_paragraph(paragraph)
    doc.save(file_path)

def generate_pdf(user, org_name, file_path, fake, theme_content):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Helvetica", "B", 16)

    # Encode title and body text to handle unsupported characters
    def encode_text(text):
        # Replace common problematic characters
        replacements = {
            '’': "'", '–': '-', '“': '"', '”': '"', '—': '--', '…': '...'
        }
        for old, new in replacements.items():
            text = text.replace(old, new)
        # Encode to latin-1, ignoring any characters that can't be represented
        return text.encode('latin-1', 'ignore').decode('latin-1')

    title = f'{org_name} - {theme_content["pdf_title"]}'
    pdf.cell(0, 10, encode_text(title), new_x="LMARGIN", new_y="NEXT", align='C')

    pdf.set_font("Helvetica", "", 12)
    pdf.cell(0, 10, f"Prepared by: {user}", new_x="LMARGIN", new_y="NEXT", align='C')
    pdf.ln(10)

    pdf_body = theme_content.get("pdf_body", "")
    
    if isinstance(pdf_body, list):
        for paragraph in pdf_body:
            pdf.multi_cell(0, 10, encode_text(paragraph))
            pdf.ln(5)
    elif isinstance(pdf_body, str):
        for paragraph in pdf_body.split('\n'):
            pdf.multi_cell(0, 10, encode_text(paragraph))
            pdf.ln(5)
            
    pdf.output(file_path)

def generate_spreadsheet(user, org_name, file_path, fake, theme_content):
    wb = xlsxwriter.Workbook(file_path)
    ws = wb.add_worksheet()
    bold = wb.add_format({'bold': True})
    ws.write('A1', f'{org_name} - {theme_content["sheet_title"]}', bold)
    ws.write('A2', 'Prepared by:', bold)
    ws.write('B2', user)
    headers = theme_content.get("sheet_headers", [])
    for col, header in enumerate(headers):
        ws.write(4, col, header, bold)
    sheet_data = theme_content.get("sheet_data", [])
    for row_num, row_data in enumerate(sheet_data, 5):
        for col_num, cell_data in enumerate(row_data):
            ws.write(row_num, col_num, cell_data)
    wb.close()

def generate_presentation(user, org_name, file_path, fake, theme_content):
    prs = Presentation()
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    title = slide.shapes.title
    subtitle = slide.placeholders[1]
    title.text = f'{org_name} - {theme_content["ppt_title"]}'
    subtitle.text = f"Presented by {user}\n{fake.date()}"

    bullet_slide_layout = prs.slide_layouts[1]
    for slide_title, bullet_points in theme_content.get("ppt_slide_details", {}).items():
        slide = prs.slides.add_slide(bullet_slide_layout)
        shapes = slide.shapes
        shapes.title.text = slide_title
        body_shape = shapes.placeholders[1]
        tf = body_shape.text_frame
        tf.clear()

        if isinstance(bullet_points, list):
            for point in bullet_points:
                p = tf.add_paragraph()
                p.text = point
                p.level = 1
        else:
            p = tf.add_paragraph()
            p.text = str(bullet_points)

    prs.save(file_path)

def main():
    parser = argparse.ArgumentParser(description="Generate unique, random files for a small business using the Gemini API.")
    parser.add_argument("--users", nargs="+", required=True, help="List of usernames.")
    parser.add_argument("--num-files", type=int, default=5, help="Number of files per user.")
    parser.add_argument("--org-name", required=True, help="Name of the organization.")
    parser.add_argument("--theme", required=True, help="Business model theme.")
    parser.add_argument("--api-key", help="Gemini API key.")
    parser.add_argument("--roles", nargs="+", default=["CEO", "CFO", "CTO", "HR_Manager", "Sales_Manager", "Marketing_Manager", "Project_Manager", "Accountant", "Software_Engineer", "Customer_Support_Specialist"], help="List of roles to generate files for.")
    parser.add_argument("--file-types", type=json.loads, default='["document", "spreadsheet", "presentation", "image", "pdf"]', help="JSON list of file types to generate.")
    parser.add_argument("--doc-types", type=json.loads, default='["Internal Memo", "Project Proposal", "Competitive Analysis", "Budget Report", "Meeting Minutes", "Business Requirements Document (BRD)", "Standard Operating Procedure (SOP)", "Marketing Plan", "Sales Strategy", "Quarterly Business Review (QBR)", "Press Release", "Employee Onboarding Checklist", "Performance Improvement Plan (PIP)", "Job Description", "Offer Letter", "Vendor Contract", "Non-Disclosure Agreement (NDA)", "Service Level Agreement (SLA)", "Incident Report", "Change Request Form"]', help="JSON list of document types.")
    parser.add_argument("--sheet-types", type=json.loads, default='["Financial Statement", "Project Timeline", "Sales Tracker", "Inventory List", "Employee Directory", "Budget vs. Actuals", "Marketing Campaign Tracker", "Customer Relationship Management (CRM) Data", "Lead Generation Funnel", "Social Media Content Calendar", "Gantt Chart", "Resource Allocation Plan", "Risk Register", "Issue Tracker", "Payroll Register", "Accounts Receivable Aging", "Accounts Payable Aging", "Cash Flow Statement", "Burn Down Chart", "Capacity Planner"]', help="JSON list of spreadsheet types.")
    parser.add_argument("--ppt-types", type=json.loads, default='["Quarterly Review", "New Product Pitch", "Market Trend Analysis", "Team Training Guide", "Sales Kick-Off (SKO) Presentation", "Investor Pitch Deck", "Company All-Hands Meeting", "Project Kick-off Presentation", "Go-to-Market Strategy", "Customer Onboarding Guide", "Product Demonstration", "Competitive Landscape Review", "Post-Mortem Analysis", "Annual General Meeting (AGM) Presentation", "Change Management Communication", "Technology Roadmap", "Financial Results Briefing", "HR Policy Overview", "Crisis Communication Plan", "Partner Program Overview"]', help="JSON list of presentation types.")
    parser.add_argument("--pdf-types", type=json.loads, default='["Employee Manual", "Analyst Report", "User Guide", "Summary Report", "Design Guide", "Invoice", "Purchase Order", "White Paper", "Case Study", "Annual Report", "Compliance Certificate", "Legal Contract", "Technical Manual", "Product Brochure", "Marketing eBook", "Signed Agreement", "Official Company Statement", "Terms of Service", "Privacy Policy", "Security Whitepaper"]', help="JSON list of PDF types.")
    args = parser.parse_args()

    fake = Faker()

    role_file_types = {
        "CEO": ["document", "presentation", "pdf"],
        "CFO": ["spreadsheet", "document", "pdf"],
        "CTO": ["document", "presentation", "spreadsheet"],
        "HR_Manager": ["document", "pdf", "spreadsheet"],
        "Sales_Manager": ["presentation", "spreadsheet", "document"],
        "Marketing_Manager": ["presentation", "document", "image"],
        "Project_Manager": ["spreadsheet", "document", "presentation"],
        "Accountant": ["spreadsheet", "pdf"],
        "Software_Engineer": ["document", "spreadsheet"],
        "Customer_Support_Specialist": ["document", "pdf"],
    }

    file_generators = {
        "document": generate_document,
        "spreadsheet": generate_spreadsheet,
        "presentation": generate_presentation,
        "image": lambda user, org, path, f, content: generate_image_from_api(content.get('image_prompt'), path, api_key=args.api_key),
        "pdf": generate_pdf,
    }
    file_extensions = {
        "document": ".docx", "spreadsheet": ".xlsx",
        "presentation": ".pptx", "image": ".png", "pdf": ".pdf",
    }

    for user in args.users:
        role = random.choice(args.roles)
        output_dir = os.path.join("output", user)
        os.makedirs(output_dir, exist_ok=True)
        for i in range(args.num_files):
            if args.file_types:
                file_type = random.choice(args.file_types)
            else:
                file_type = random.choice(role_file_types.get(role, ["document"]))

            print(f"--- Generating unique content for {user} ({role}) - {file_type} ---")
            theme_content = generate_unique_gemini_content(args.theme, role, file_type, args.doc_types, args.sheet_types, args.ppt_types, args.pdf_types, api_key=args.api_key)

            if theme_content:
                title = theme_content.get("doc_title") or theme_content.get("sheet_title") or theme_content.get("ppt_title") or theme_content.get("pdf_title") or f"image_{i+1}"
                file_name = f"{sanitize_filename(title)}{file_extensions[file_type]}"
                file_path = os.path.join(output_dir, file_name)

                print(f"--- Saving file: {file_path} ---")
                try:
                    file_generators[file_type](user, args.org_name, file_path, fake, theme_content)
                except Exception as e:
                    print(f"Error generating file {file_path}: {e}")
            else:
                print(f"Skipping file due to content generation failure.")

if __name__ == "__main__":
    main()