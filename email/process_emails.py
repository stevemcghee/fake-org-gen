# This file was generated by the Gemini CLI.
# For more information, see: https://github.com/google-gemini/gemini-cli
#
#      ,ad8888ba,
#     d8"'    `"8b
#    d8'        `8b
#    88          88
#    88          88
#    Y8,        ,8P
#     Y8a.    .a8P
#      `"Y8888Y"'
#

import csv
import random
import os
import sys
import json
import re

# Increase the field size limit for the CSV reader
max_int = sys.maxsize
while True:
    # Decrease the max int value by half each time to find a value that works
    try:
        csv.field_size_limit(max_int)
        break
    except OverflowError:
        max_int = int(max_int / 2)

def load_replacement_emails(config_path):
    """Loads users and domain from config.json to generate a list of emails."""
    try:
        with open(config_path, 'r') as f:
            config = json.load(f)
        domain = config['domain']['value']
        users = config['users']['value'].keys()
        return [f"{user}@{domain}" for user in users]
    except (FileNotFoundError, KeyError) as e:
        print(f"Error loading or parsing config file {config_path}: {e}")
        return []

def sample_emails_from_csv(csv_path, replacement_emails, num_samples=5):
    """
    Uses reservoir sampling to select a random sample of emails from a large
    CSV file, replaces email addresses, and saves them as .eml files.
    """
    if not replacement_emails:
        print("No replacement emails provided. Cannot perform email replacement.")
        return

    reservoir = []
    message_col_index = -1
    
    # First, find the index of the 'message' column from the header
    with open(csv_path, 'r', encoding='utf-8', errors='ignore') as f:
        reader = csv.reader(f)
        try:
            header = next(reader)
            if 'message' in header:
                message_col_index = header.index('message')
            else:
                print("Error: 'message' column not found in CSV header.")
                return
        except StopIteration:
            print("Error: CSV file is empty.")
            return

    # Now, perform reservoir sampling
    with open(csv_path, 'r', encoding='utf-8', errors='ignore') as f:
        reader = csv.reader(f)
        next(reader) # Skip header again
        
        for i, row in enumerate(reader):
            if i < num_samples:
                reservoir.append(row)
            else:
                j = random.randint(0, i)
                if j < num_samples:
                    reservoir[j] = row

    # Create a directory to save the .eml files
    output_dir = os.path.join(os.path.dirname(csv_path), 'email_samples')
    os.makedirs(output_dir, exist_ok=True)

    # Save the sampled emails as .eml files
    for i, sample in enumerate(reservoir):
        if len(sample) > message_col_index:
            email_content = sample[message_col_index]
            
            # Replace all email addresses found in the message
            email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
            email_content = re.sub(email_pattern, lambda m: random.choice(replacement_emails), email_content)

            file_path = os.path.join(output_dir, f"sample_email_{i + 1}.eml")
            with open(file_path, 'w', encoding='utf-8') as f_out:
                f_out.write(email_content)
            print(f"Saved sample {i + 1} to {file_path}")
        else:
            print(f"Warning: Sample {i + 1} was malformed and skipped.")


if __name__ == "__main__":
    script_dir = os.path.dirname(os.path.abspath(__file__))
    csv_file = os.path.join(script_dir, 'emails.csv')
    config_file = os.path.join(script_dir, '..', 'config.json')
    
    replacement_emails = load_replacement_emails(config_file)
    if replacement_emails:
        sample_emails_from_csv(csv_file, replacement_emails, num_samples=100)